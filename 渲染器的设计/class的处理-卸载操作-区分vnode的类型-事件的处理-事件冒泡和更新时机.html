<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://unpkg.com/@vue/reactivity@3.0.5/dist/reactivity.global.js"></script>
</head>

<body>
    <div id="app"></div>
</body>
<script>
    // function shouldSetAsProps(el, key, value) {
    //     if (key === 'form' && el.tagName === 'INPUT') return false
    //     return key in el
    // }

    // function createRenderer(options) {

    //     const {
    //         createElement,
    //         insert,
    //         setElementText,
    //         patchProps
    //     } = options

    //     function mountElement(vnode, container) {
    //         const el = vnode.el = createElement(vnode.type)
    //         if (typeof vnode.children === 'string') {
    //             setElementText(el, vnode.children)
    //         } else if (Array.isArray(vnode.children)) {
    //             vnode.children.forEach(child => {
    //                 patch(null, child, el)
    //             })
    //         }

    //         if (vnode.props) {
    //             for (const key in vnode.props) {
    //                 patchProps(el, key, null, vnode.props[key])
    //             }
    //         }

    //         insert(el, container)
    //     }

    //     function patchElement(n1, n2) {
    //         const el = n2.el = n1.el
    //         const oldProps = n1.props
    //         const newProps = n2.props

    //         for (const key in newProps) {
    //             if (newProps[key] !== oldProps[key]) {
    //                 patchProps(el, key, oldProps[key], newProps[key])
    //             }
    //         }
    //         for (const key in oldProps) {
    //             if (!(key in newProps)) {
    //                 patchProps(el, key, oldProps[key], null)
    //             }
    //         }
    //     }

    //     function unmount(vnode) {
    //         const parent = vnode.el.parentNode
    //         if (parent) {
    //             parent.removeChild(vnode.el)
    //         }
    //     }

    //     function patch(n1, n2, container) {
    //         if (n1 && n1.type !== n2.type) {
    //             unmount(n1)
    //             n1 = null
    //         }

    //         const { type } = n2

    //         if (typeof type === 'string') {
    //             if (!n1) {
    //                 mountElement(n2, container)
    //             } else {
    //                 patchElement(n1, n2)
    //             }
    //         } else if (typeof type === 'object') {
    //             // 组件
    //         }
    //     }

    //     function render(vnode, container) {
    //         if (vnode) {
    //             // 新 vnode 存在，将其与旧 vnode 一起传递给 patch 函数进行打补丁
    //             patch(container._vnode, vnode, container)
    //         } else {
    //             if (container._vnode) {
    //                 // 旧 vnode 存在，且新 vnode 不存在，说明是卸载(unmount)操作
    //                 unmount(container._vnode)
    //             }
    //         }
    //         // 把 vnode 存储到 container._vnode 下，即后续渲染中的旧 vnode
    //         container._vnode = vnode
    //     }

    //     return {
    //         render
    //     }
    // }

    // const renderer = createRenderer({
    //     createElement(tag) {
    //         return document.createElement(tag)
    //     },
    //     setElementText(el, text) {
    //         el.textContent = text
    //     },
    //     insert(el, parent, anchor = null) {
    //         parent.insertBefore(el, anchor)
    //     },
    //     patchProps(el, key, prevValue, nextValue) {
    //         if (/^on/.test(key)) {
    //             const invokers = el._vei || (el._vei = {})
    //             let invoker = invokers[key]
    //             const name = key.slice(2).toLowerCase()
    //             if (nextValue) {
    //                 if (!invoker) {
    //                     invoker = el._vei[key] = (e) => {
    //                         console.log(e.timeStamp)
    //                         console.log(invoker.attached)
    //                         if (e.timeStamp < invoker.attached) return
    //                         if (Array.isArray(invoker.value)) {
    //                             invoker.value.forEach(fn => fn(e))
    //                         } else {
    //                             invoker.value(e)
    //                         }
    //                     }
    //                     invoker.value = nextValue
    //                     invoker.attached = performance.now()
    //                     el.addEventListener(name, invoker)
    //                 } else {
    //                     invoker.value = nextValue
    //                 }
    //             } else if (invoker) {
    //                 el.removeEventListener(name, invoker)
    //             }
    //         } else if (key === 'class') {
    //             el.className = nextValue || ''
    //         } else if (shouldSetAsProps(el, key, nextValue)) {
    //             const type = typeof el[key]
    //             if (type === 'boolean' && nextValue === '') {
    //                 el[key] = true
    //             } else {
    //                 el[key] = nextValue
    //             }
    //         } else {
    //             el.setAttribute(key, nextValue)
    //         }
    //     }
    // })

    // const { effect, ref } = VueReactivity

    // const bol = ref(false)

    // effect(() => {
    //     const vnode = {
    //         type: 'div',
    //         props: bol.value ? {
    //             onClick: () => {
    //                 alert('父元素 clicked')
    //             }
    //         } : {},
    //         children: [
    //             {
    //                 type: 'p',
    //                 props: {
    //                     onClick: () => {
    //                         bol.value = true
    //                     }
    //                 },
    //                 children: 'text'
    //             }
    //         ]
    //     }
    //     renderer.render(vnode, document.querySelector('#app'))
    // })

    function shouldSetAsProps(el, key, value) {
        if (key === 'form' && el.tagName === 'INPUT') return false
        return key in el
    }
    function createRenderer(options) {
        const {
            createElement,
            setElementText,
            insert,
            patchProps
        } = options

        function patch(oldVNode, newVNode, container) {
            if (oldVNode && oldVNode.type !== newVNode.type) {
                unMounted(oldVNode)
                oldVNode = null
            }

            const { type } = newVNode
            if (typeof type === 'string') {
                if (!oldVNode) {
                    mountElement(newVNode, container)
                } else {
                    // n1存在，意味着要打补丁，暂时省略
                    patchElement(oldVNode, newVNode)
                }
            } else if (typeof type === 'object') {
                // 如果newVNode的类型是对象，则它描述的是对象
            } else if (typeof type === 'xxx') {

            }

        }
        function patchElement(n1, n2) {
            const el = n2.el = n1.el
            const oldProps = n1.props
            const newProps = n2.props

            for (const key in newProps) {
                if (newProps[key] !== oldProps[key]) {
                    patchProps(el, key, oldProps[key], newProps[key])
                }
            }
            for (const key in oldProps) {
                if (!(key in newProps)) {
                    patchProps(el, key, oldProps[key], null)
                }
            }
        }

        // 添加节点
        function mountElement(vNode, container) {
            // const el = document.createElement(vNode.type)
            const el = vNode.el = createElement(vNode.type) // 将元素关联到虚拟节点上
            // 处理子节点
            if (typeof vNode.children === 'string') {
                // el.textContent = vNode.children
                setElementText(el, vNode.children)
            } else if (Array.isArray(vNode.children)) {
                vNode.children.forEach(child => {
                    patch(null, child, el)
                })
            }

            if (vNode.props) {
                for (const key in vNode.props) {
                    const value = vNode.props[key]
                    patchProps(el, key, null, value)
                }
            }

            // container.appendChild(el)
            insert(el, container)
        }

        function unMounted(vNode) {
            const parent = vNode.el.parentNode
            if (parent) {
                parent.removeChild(vNode.el)
            }
        }

        function render(vNode, container) {
            if (vNode) {
                // 如果传入了新vnode, 将其与旧vnode一起传递给patch函数，进行打补丁
                patch(container._vNode, vNode, container)
            } else {
                // 没传新vnode，且有旧节点存在，则卸载
                if (container._vNode) {
                    unMounted(container._vNode)
                }
            }
            container._vNode = vNode
        }

        return {
            render
        }
    }
    const renderer = createRenderer({
        createElement(tagName) {
            return document.createElement(tagName)
        },
        setElementText(el, text) {
            el.textContent = text
        },
        insert(el, parent, anchor = null) {
            parent.appendChild(el)
        },
        patchProps(el, key, prevValue, nextValue) {
            if (/^on/.test(key)) {
                const eventName = key.slice(2).toLowerCase()
                let invokers = el._vei || (el._vei = {})
                let invoker = invokers[key]
                if (nextValue) {
                    if (!invoker) {
                        invoker = el._vei[key] = (e) => {
                            console.log(e.timeStamp)
                            console.log(invoker.attached)
                            if (e.timeStamp < invoker.attached) return
                            if (Array.isArray(invoker.value)) {
                                invoker.value.forEach(fn => fn(e))
                            } else {
                                invoker.value(e)
                            }
                        }
                        invoker.value = nextValue
                        invoker.attached = performance.now()
                        console.log(el, eventName, invoker.value, invoker.attached);
                        el.addEventListener(eventName, invoker)
                    } else {
                        invoker.attached = performance.now()
                        invoker.value = nextValue
                    }
                } else if (invoker) {
                    el.removeEventListener(eventName, invoker)
                }
                // prevValue && el.removeEventListener(eventName, prevValue)
                // el.addEventListener(eventName, nextValue)
            } else if (key === 'class') { // 对class做特殊处理
                el.className = nextValue || ''
            } else if (shouldSetAsProps(el, key, nextValue)) {
                const type = typeof el[key]

                if (type === 'boolean' && nextValue === '') {
                    el[key] = true
                } else {
                    el[key] = nextValue
                }
            } else {
                el.setAttribute(key, nextValue)
            }
        }
    })
    const vNode = {
        type: 'div',
        props: {
            class: 'foo bar',
            onClick: [
                () => {
                    alert('clicked')
                },
                () => {
                    alert('clicked2')
                },
            ],
            onContextMenu: () => {
                alert('onContentMenu')
            }
        },
        children: 'hello'
    }

    const { effect, ref } = VueReactivity

    const bol = ref(false)

    effect(() => {
        const vnode = {
            type: 'div',
            props: bol.value ? {
                onClick: () => {
                    console.log('hi', performance.now());
                    alert('父元素clicked')
                }
            } : {
                onClick: () => { }
            },
            children: [
                {
                    type: 'p',
                    props: {
                        onClick: () => {
                            bol.value = true
                            console.log(bol.value);
                        }
                    },
                    children: 'text'
                }
            ]
        }
        renderer.render(vnode, document.querySelector("#app"))
    })
</script>

</html>